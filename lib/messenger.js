import awsIot from 'aws-iot-device-sdk'
import jwt from 'jsonwebtoken'
import mqtt from 'async-mqtt'
import azureIot from 'azure-iot-device'
import { clientFromConnectionString } from 'azure-iot-device-mqtt'

/**
 * Abstract superclass for cloud provider's IoT data messaging.
 *
 * Use Messenger.create() (defined at bottom) to create an instance of the
 * appropriate subclass.
 */
export default class Messenger {
    /** Establishes 'defaultConsumerTopic' as fallback messaging topic to publish data to cloud. */
    constructor() {
        this.defaultConsumerTopic = 'sensors'
    }

    /**
     * Connects to the cloud providers messenging facility. Must establish
     * this connection before any messaging.
     */
    async connect() {
        throw new Error("Abstract method")
    }

    /**
     * Connects to the cloud providers messenging facility. Must establish
     * this connection before any messaging.
     *
     * This method remains for historical reasons. Prefer use of connect().
     */
    connectSync() {
        throw new Error("Abstract method")
    }

    /**
     * Provides the actual topic used to send data to the cloud provider's messaging
     * facility, based on the configured value. Allows a messenger to customize the
     * topic.
     */
    finalizeConsumerTopic(configTopic) {
        return configTopic
    }

    /**
     * Verifies that *all* environment variables generated by provisioning actually exist.
     */
    isRegistrationComplete() {
        return false
    }

    /**
     * Determines if this messenger use connectSync() rather than connect().
     *
     * This method will be removed when connectSync() is removed.
     */
    isSyncConnect() {
        return false
    }

    /**
     * Verifies that *none* environment variables generated by provisioning actually exist.
     */
    isUnregistered() {
        return true
    }

    /**
     * Publishes the message to the cloud provider on the provided topic.
     */
    publish(topic, message) {
        throw new Error("Abstract method")
    }
}

/** Messenger for AWS IoT Core. */
class AwsMessenger extends Messenger {
    connectSync() {
        console.log(`Connecting to host ${process.env.AWS_DATA_ENDPOINT}`)
        this.mqtt = awsIot.device({
            privateKey: Buffer.from(process.env.AWS_PRIVATE_KEY, 'base64'),
            clientCert: Buffer.from(process.env.AWS_CERT, 'base64'),
            caPath: process.env.AWS_ROOT_CA_PATH,
            clientId: process.env.RESIN_DEVICE_UUID,
            host: process.env.AWS_DATA_ENDPOINT,
            })
        this.mqtt.on('connect', function () {
            console.log("Connected to IoT Core messaging")
        })
    }

    isRegistrationComplete() {
        return process.env.AWS_PRIVATE_KEY
                && process.env.AWS_CERT
    }

    isSyncConnect() {
        return true
    }

    isUnregistered() {
        return !process.env.AWS_PRIVATE_KEY
                && !process.env.AWS_CERT
    }

    publish(topic, message) {
        //console.log(`Messenger pub: ${message.toString()}`)
        this.mqtt.publish(topic, message)
    }

    toString() {
        return "AWS cloud messenger"
    }
}

/** Messenger for MS Azure IoT. */
class AzureMessenger extends Messenger {
    connectSync() {
        console.log(`Connecting to host ${process.env.AZURE_HUB_HOST}`)
        //console.debug("connstr:", `HostName=${process.env.AZURE_HUB_HOST};DeviceId=${process.env.RESIN_DEVICE_UUID};x509=true`)
        this.mqtt = clientFromConnectionString(
            `HostName=${process.env.AZURE_HUB_HOST};DeviceId=${process.env.RESIN_DEVICE_UUID};x509=true`)
        //console.debug("cert:", Buffer.from(process.env.AZURE_CERT, 'base64').toString())
        //console.debug("private key:", Buffer.from(process.env.AZURE_PRIVATE_KEY, 'base64').toString())
        const options = {
           cert: Buffer.from(process.env.AZURE_CERT, 'base64').toString(),
           key: Buffer.from(process.env.AZURE_PRIVATE_KEY, 'base64').toString()
        }
        this.mqtt.setOptions(options)

        this.mqtt.open(function (err) {
            if (err) {
                console.warn("Cannot connect to Azure IoT:", err.toString())
            } else {
                console.log("Connected to Azure IoT messaging")
            }
        })
    }

    isRegistrationComplete() {
        return process.env.AZURE_PRIVATE_KEY
                && process.env.AZURE_CERT
    }

    isSyncConnect() {
        return true
    }

    isUnregistered() {
        return !process.env.AZURE_PRIVATE_KEY
                && !process.env.AZURE_CERT
    }

    publish(topic, message) {
        //console.debug(`Messenger pub: ${message.toString()}`)
        let msg = new azureIot.Message(message)
        msg.contentEncoding = 'utf-8'
        msg.contentType = 'application/json'
        msg.properties.add('topic', topic)
        
        this.mqtt.sendEvent(msg, function (err) {
            if (err) {
                console.warn("Error sending message:", err.toString())
            }
        })
    }

    toString() {
        return "Azure cloud messenger"
    }
}

/**
 * Messenger for GCP IoT Core.
 *
 * Messaging token lifetime defaults to maximum of 24 hours, implemented with these
 * environment variables:
 *
 * * GCP_TOKEN_LIFETIME Lifetime in minutes
 * * GCP_RENEWAL_START Time when token is renewed, relative to token expiration;
 *   for example a value of 15 means renewal occurs 15 minutes before expiration
 *
 * GCP_RENEWAL_START will be more valuable if we set up a replacement MQTT
 * connection like the 'mqtt' instance variable *before* ending the current connection.
 * This overlap will ensure we never lose connection to IoT Core.
 */
class GcpMessenger extends Messenger {
    constructor() {
        super()
        this.defaultConsumerTopic = 'events'
        if (!process.env.MESSAGING_HOST) {
            process.env.MESSAGING_HOST = 'mqtt.googleapis.com'
        }

        this.mqttParams = {
          host: process.env.MESSAGING_HOST,
          port: 8883,
          clientId: process.env.GCP_CLIENT_PATH,
          username: 'unused',
          protocol: 'mqtts',
          secureProtocol: 'TLSv1_2_method'
        }

        if (!process.env.GCP_TOKEN_LIFETIME) {
            process.env.GCP_TOKEN_LIFETIME = 24 * 60
        }
        // Adapt default renewal start time if token lifetime is short; probably for testing.
        if (!process.env.GCP_RENEWAL_START) {
            if (process.env.GCP_TOKEN_LIFETIME >= 20) {
                process.env.GCP_RENEWAL_START = 15
            } else {
                process.env.GCP_RENEWAL_START = 1
            }
        }
    }

    /**
     * Connects to GCP messaging. Sets 'connected' property on success. Caller
     * must catch errors.
     */
    async connect() {
        console.log(`Connecting to host ${this.mqttParams.host}`)

        let params = Object.assign({ password: this.createJwt(process.env.GCP_PROJECT_ID, 'ES256') },
                                   this.mqttParams)
        //console.debug("GCP connect params:", JSON.stringify(params))
        this.mqtt = await mqtt.connectAsync(params)
        this.connected = true
        setTimeout( async () => { await this.reconnect() }, (process.env.GCP_TOKEN_LIFETIME - process.env.GCP_RENEWAL_START) * 60 * 1000)
        console.log("Connected to IoT Core messaging");
    }

    /** Create JWT required for IoT Core renewal. */
    createJwt(projectId, secureAlgorithm) {
        const token = {
          iat: parseInt(Date.now() / 1000),
          exp: parseInt(Date.now() / 1000) + process.env.GCP_TOKEN_LIFETIME * 60,
          aud: projectId
        }
        return jwt.sign(token, Buffer.from(process.env.GCP_PRIVATE_KEY, 'base64'),
                        { algorithm: secureAlgorithm})
    }

    /** Assumes the configured value does not include device-specific parent path. */
    finalizeConsumerTopic(configTopic) {
        return `${process.env.GCP_DATA_TOPIC_ROOT}/${configTopic}`
    }

    /**
     * Close current connection to GCP if any, and reconnect. Implements required
     * refresh of JWT token.
     *
     * Tries to connect three times; exits the process if fails. Best to just try
     * to restart the process in this case.
     */
    async reconnect() {
        console.log("Refreshing GCP messaging token")
        let count = 0
        const maxTries = 3
        const delay = 5
        do { 
            try {
                count++
                if (this.connected) {
                    await this.mqtt.end()
                    this.connected = false
                }
                await this.connect()
                break
            } catch(e) {
                console.warn("Cannot connect to GCP:", e)
                if (count < maxTries) {
                    console.log(`Retry in ${delay} seconds`)
                    await new Promise(r => setTimeout(r, delay * 1000))
                } else {
                    console.warn(`Retries exhausted`)
                }
            }
        } while(count < maxTries)

        if (!this.connected) {
            process.exit(1)
        }
    }

    isRegistrationComplete() {
        return process.env.GCP_PRIVATE_KEY
                && process.env.GCP_CLIENT_PATH
                && process.env.GCP_DATA_TOPIC_ROOT
                && process.env.GCP_PROJECT_ID
    }

    isUnregistered() {
        return !process.env.GCP_PRIVATE_KEY
                && !process.env.GCP_CLIENT_PATH
                && !process.env.GCP_DATA_TOPIC_ROOT
                && !process.env.GCP_PROJECT_ID
    }

    publish(topic, message) {
        //console.log(`Messenger pub: ${message.toString()}`)
        if (this.connected) {
            this.mqtt.publish(topic, message)
        } else {
            console.log("Can't publish; not connected")
        }
    }

    toString() {
        return "GCP cloud messenger"
    }
}

/**
 * Static method to reate appropriate subclass
 */
Messenger.create = function(cloudProvider) {
    switch (cloudProvider) {
    case "AWS":
        return new AwsMessenger()
    case "AZURE":
        return new AzureMessenger()
    case "GCP":
        return new GcpMessenger()
    default:
        throw Error(`cloudProvider ${cloudProvider} unrecognized`)
    }
}
